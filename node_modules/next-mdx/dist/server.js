function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = require('fs');
var matter = _interopDefault(require('gray-matter'));
var hasha = _interopDefault(require('hasha'));
var renderToString = _interopDefault(require('next-mdx-remote/render-to-string'));
var NodeCache = _interopDefault(require('node-cache'));
var glob = _interopDefault(require('fast-glob'));
var path = _interopDefault(require('path'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const mdxCache = new NodeCache();

const DEFAULT_CONFIG_PATH = "next-mdx.json";
async function getConfig() {
  const configPath = path.resolve(`${process.cwd()}/${DEFAULT_CONFIG_PATH}`);

  try {
    // TODO: Figure out dynamic import.
    // Switch to next-mdx.config.js?
    const json = await fs.promises.readFile(configPath, "utf-8");
    return JSON.parse(json);
  } catch (error) {
    console.error(error);
  }
}
async function getSourceConfig(source) {
  const config = await getConfig();

  if (!config || !config[source]) {
    throw new Error(`Type ${source} does not exist in ${DEFAULT_CONFIG_PATH}`);
  }

  return _extends({
    sortBy: "title",
    sortOrder: "asc"
  }, config[source]);
}

async function getFiles(sourceName) {
  const {
    contentPath,
    basePath
  } = await getSourceConfig(sourceName);
  const files = await glob(`${contentPath}/**/*.{md,mdx}`);
  if (!files.length) return [];
  return files.map(filepath => {
    let slug = filepath.replace(contentPath, "").replace(/^\/+/, "").replace(new RegExp(path.extname(filepath) + "$"), "");
    slug = slug.replace(/\/?index$/, "");
    return {
      filepath,
      slug,
      url: basePath ? `${basePath.replace(/\/$/, "")}/${slug}` : null
    };
  });
}

async function getMdxNode(sourceName, context, params) {

  const node = await getNode(sourceName, context);
  if (!node) return null;
  return _extends({}, node, {
    mdx: await renderNodeMdx(node, params)
  });
}
async function getAllMdxNodes(sourceName, params) {
  const nodes = await getAllNodes(sourceName);
  if (!nodes.length) return [];
  return Promise.all(nodes.map(async node => _extends({}, node, {
    mdx: await renderNodeMdx(node, params)
  })));
}

async function renderNodeMdx(node, params) {
  return await renderToString(node.content, _extends({}, params, {
    scope: _extends({}, params == null ? void 0 : params.scope, node.frontMatter)
  }));
}

async function getNode(sourceName, context) {
  const files = await getFiles(sourceName);
  if (!files.length) return null;
  const slug = typeof context === "string" ? context : context.params.slug ? context.params.slug.join("/") : "";
  const [file] = files.filter(file => file.slug === slug);
  if (!file) return null;
  const node = await buildNodeFromFile(file);
  return _extends({}, node, {
    relationships: await getNodeRelationships(node)
  });
}
async function getAllNodes(sourceName) {
  const {
    sortBy,
    sortOrder
  } = await getSourceConfig(sourceName);
  const files = await getFiles(sourceName);
  if (!files.length) return [];
  const nodes = await Promise.all(files.map(async file => {
    const node = await buildNodeFromFile(file);
    return _extends({}, node, {
      relationships: await getNodeRelationships(node)
    });
  }));
  const adjust = sortOrder === "desc" ? -1 : 1;
  return nodes.sort((a, b) => {
    if (a.frontMatter[sortBy] < b.frontMatter[sortBy]) {
      return -1 * adjust;
    }

    if (a.frontMatter[sortBy] > b.frontMatter[sortBy]) {
      return 1 * adjust;
    }

    return 0;
  });
}

async function buildNodeFromFile(file) {
  return _extends({}, file, await getFileData(file), {
    mdx: {
      compiledSource: "",
      renderedOutput: ""
    }
  });
}

async function getFileData(file) {
  const raw = await fs.promises.readFile(file.filepath, "utf-8");
  const hash = hasha(raw.toString());
  const cachedContent = mdxCache.get(hash);

  if ((cachedContent == null ? void 0 : cachedContent.hash) === hash) {
    // console.info(`HIT for ${file.slug}`)
    return cachedContent;
  } // console.info(`MISS for ${file.slug}`)


  const {
    content,
    data: frontMatter
  } = matter(raw);
  const fileData = {
    hash,
    content,
    frontMatter
  };
  mdxCache.set(hash, fileData);
  return fileData;
}

async function getNodeRelationships(node) {
  const relationships = {};
  const config = await getConfig();

  for (const key of Object.keys(node.frontMatter)) {
    if (!config[key]) continue;
    const values = node.frontMatter[key];
    if (!values) continue;
    const valueAsArray = Array.isArray(values) ? values : [values];
    relationships[key] = await Promise.all(valueAsArray.map(async value => await getNode(key, value)));
  }

  return relationships;
}

async function getMdxPathsRaw(sourceName) {
  const nodes = await getAllNodes(sourceName);
  if (!nodes.length) return [];
  return await Promise.all(nodes.map(async node => {
    return _extends({}, node, {
      params: {
        slug: node.slug.split("/")
      }
    });
  }));
}
async function getMdxPaths(sourceName) {
  const paths = await getMdxPathsRaw(sourceName);
  return paths.map(({
    params
  }) => ({
    params
  }));
}

exports.getAllMdxNodes = getAllMdxNodes;
exports.getAllNodes = getAllNodes;
exports.getFileData = getFileData;
exports.getMdxNode = getMdxNode;
exports.getMdxPaths = getMdxPaths;
exports.getMdxPathsRaw = getMdxPathsRaw;
exports.getNode = getNode;
//# sourceMappingURL=server.js.map
